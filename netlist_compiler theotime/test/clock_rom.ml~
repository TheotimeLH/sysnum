(* ========== Paramètres ========== *)

let number_steps = ref max_int
let print_sorties = ref true
let dossier_rom = ref "rom_test"

(* ========== Fonctions auxiliaires ========== *)

(* ==== Pour passer des strb aux int ==== *)

(* strb : chaine de caractères où est écrit un int en binaire, exemple : "0010"
  En lecture, si on attend n bits et qu'on en reçoit moins ou plus, on
	crie, si c'est un input on le redemande, si c'est dans la ROM le cri
	provoque une erreur.
  Rem : tout chiffre > 0 est pris pour un 1, exemple : "0502" -> "0101" 

	intv : nos values, de la forme (len,int) où les informations sont dans
	les len premiers bits de l'int.																					*)
exception Wrong_length

let strb_to_intv s k = (* k : le nb de bits voulus *)
	if String.length s <> k then raise Wrong_length
	else begin let n = ref 0 in
		for i = 0 to k-1 do
			n := (!n lsl 1) + (if int_of_char s.[i] > 48 then 1 else 0) done ;
		(k,!n) end

let intv_to_strb (len,n) =
	let s = ref "" and k = ref n in
	for _ = 1 to len do
		s := string_of_int (!k mod 2) ^ !s ;
		k := !k lsr 1 done;
	!s

(* ==== Strutures ==== *)

let step = ref 0 
let nb_vars = 14
let t_nom = [|"_l_2";"_tmp";"_tmp2";"_tmp3";"c";"o";"ra";"ram";"rom";"rom0";"rom1";"s";"sram";"u"|]
let t_len = [|1;1;1;1;1;4;1;4;2;2;2;1;2;1|]
let t_val = Array.init nb_vars (fun i -> (t_len.(i),0))
let t_fait = Array.make nb_vars 0 
let t_reg = Array.make nb_vars (fun i -> (t_len.(i),0))
let info_rams = [|0,0;0,0;0,0;0,0;0,0;0,0;0,0;1,4;0,0;0,0;0,0;0,0;0,0;0,0|]
let l_roms = [10,1,2;9,1,2]
let t_roms = Array.make nb_vars [||]
let t_rams = Array.init nb_vars 
	(fun i -> let a_s,w_s = info_rams.(i) in
	Array.make (1 lsl a_s) (w_s,0))


(* ==== Entrées : input / ROM  ==== *)

let rec ask_input num = 
	Printf.printf "%s = " t_nom.(num) ;
	try (t_len.(num),strb_to_intv (readline ()) t_len.(num))
	with Wrong_length -> 
		Printf.printf "ERREUR : on demande %d bits" t_len.(num) ;
		ask_input num 

let recup_rom (num,a_size,w_size) = 
	let m = 1 lsl a_wize in
	let lit_rom file = 
		let rom = Array.make m (w_size,0) in
		let k = ref 0 in
		let end_of_file = ref false in
    while !k < m && not !end_of_file do
      incr k ;
      try
        begin
					try rom.(!k-1) <- (w_size, strb_to_intv (input_line file) w_size)
					with Wrong_length ->
						Printf.printf "ERREUR : pour la ROM de %s on \
							voulait %d bits, on a mis des 0 par défaut" t_nom.(num) w_size ;
				end
      with
        |End_of_file -> end_of_file := true ;
          print_endline "Attention, il manque des données, 0 par défaut"
        |Failure _ ->
          print_endline "Attention, il a des caractères dans le fichier"
      done;
    t_roms.(num) <- rom in

  try
    lit_rom (open_in (!dossier_rom ^ "/" ^ id ^ ".txt"))
  with
    Sys_error _ -> begin
      Printf.printf "Quelle est la ROM pour %s ? (on demande un .txt) \n\ 
				NB: Avec l'argument -rom vous pouvez indiquer un dossier \
				où chercher par défaut, actuellement %s) \n" t_nom.(num) !dossier_rom ;
      try lit_rom (open_in (read_line ()))
      with
        Sys_error _ ->
          print_endline "Fichier non trouvé, ROM initialisée avec des 0" ;
          t_roms.(num) <- Array.make n (w_size,0)
			end


(* ======== Les fonctions-variables ======== *)

(*=============*)

let var_s () = t_val.(11)

(*=======*)

let var__l_2 () = t_val.(0)

(*=======*)

let var_c () = 
	if t_fait.(4) = !step then t_val.(4) 
	else begin 
		let (len,n) = var__l_2 () in
		let n = ref n and k = ref 0 in
		for i = 0 to len do
			k := !k + ((1-(!n mod 2)) lsl i) ; n := !n lsr 1 done ;
		let valeur = (len,!k) in 
		t_val.(4) <- valeur ;
		t_fait.(4) <- !step ;
		valeur
	end

(*=======*)

let var__tmp () = 
	if t_fait.(1) = !step then t_val.(1) 
	else begin 
		let (len1,n1) = var_s () in
		let valeur = if len1<>1 then failwith " Seules les op sur 1 bit sont acceptées "
		else if n1=0 then (1,0) 
			else let (len2,n2) = var__l_2 () in 
			if len2 <> 1 then failwith " Seules les op sur 1 bit sont acceptées "
			else if n2=0 then (1,0) else (1,1) in 
		t_val.(1) <- valeur ;
		t_fait.(1) <- !step ;
		valeur
	end

(*=======*)

let var_u () = t_val.(13)

(*=======*)

let var__tmp2 () = 
	if t_fait.(2) = !step then t_val.(2) 
	else begin 
		let (len1,n1) = var_u () and (len2,n2) = var__tmp () in
		let valeur = if len1=1 && len2=1 then (1, Bool.to_int (n1<>n2))
		else failwith " Seules les op sur 1 bit sont acceptées " in

		t_val.(2) <- valeur ;
		t_fait.(2) <- !step ;
		valeur
	end

(*=======*)

let var_rom0 () = 
	if t_fait.(9) = !step then t_val.(9) 
	else begin 
		let valeur = t_roms.(9).(snd var_u () ) in
		t_val.(9) <- valeur ;
		t_fait.(9) <- !step ;
		valeur
	end

(*=======*)

let var_rom1 () = 
	if t_fait.(10) = !step then t_val.(10) 
	else begin 
		let valeur = t_roms.(10).(snd var_u () ) in
		t_val.(10) <- valeur ;
		t_fait.(10) <- !step ;
		valeur
	end

(*=======*)

let var_rom () = 
	if t_fait.(8) = !step then t_val.(8) 
	else begin 
		let valeur = if snd (var_s () ) > 0 then var_rom1 () else var_rom0 () in
		t_val.(8) <- valeur ;
		t_fait.(8) <- !step ;
		valeur
	end

(*=======*)

let var_ram () = 
	if t_fait.(7) = !step then t_val.(7) 
	else begin 
		let valeur = t_rams.(7).(snd (1,0) ) in
		t_val.(7) <- valeur ;
		t_fait.(7) <- !step ;
		valeur
	end

(*=======*)

let var_ra () = 
	if t_fait.(6) = !step then t_val.(6) 
	else begin 
		let (len,n) = var_ram ()  and i = 1 in 
		let valeur = if i+1>len then failwith "i-eme bit avec i>len" 
		else (1,(n lsr (len-i-1)) mod 2) in
		t_val.(6) <- valeur ;
		t_fait.(6) <- !step ;
		valeur
	end

(*=======*)

let var__tmp3 () = 
	if t_fait.(3) = !step then t_val.(3) 
	else begin 
		let (len1,n1) = var__tmp2 () and (len2,n2) = var_ra () in
		let valeur = if len1=1 && len2=1 then (1, Bool.to_int (n1<>n2))
		else failwith " Seules les op sur 1 bit sont acceptées " in

		t_val.(3) <- valeur ;
		t_fait.(3) <- !step ;
		valeur
	end

(*=======*)

let var_sram () = 
	if t_fait.(12) = !step then t_val.(12) 
	else begin 
		let (len,n) = var_ram () in 
		let i1 = 2 and i2 = 3 in
		let valeur = if i2+1>len || i2 < i1 then failwith "pb slice"
		else (i2-i1+1,( (n lsr (len-i2-1)) mod (1 lsl (i2-i1+1)))) in
		t_val.(12) <- valeur ;
		t_fait.(12) <- !step ;
		valeur
	end

(*=======*)

let var_o () = 
	if t_fait.(5) = !step then t_val.(5) 
	else begin 
		let (len1,n1) = var_sram () and (len2,n2) = var_rom () in
		let valeur = (len1+len2,(n1 lsl len2) + n2) in
		t_val.(5) <- valeur ;
		t_fait.(5) <- !step ;
		valeur
	end


(* ========================================= *)

let simulator () =
	List.iter recup_rom l_roms ;
	while !step < !number_steps do
		incr step ;
		(* === Calcul et affichage des sorties === *)
		Printf.printf "=> o = %s \n" (intv_to_strb (var_o ())) ;
		(* === Mise à jour des REG et des RAM === *)
		t_reg.(13) <- var__tmp3 () ;
		t_reg.(0) <- var_s () ;
		t_reg.(11) <- var_c () ;
		if snd ((1,1) ) > 0 then t_rams.(7).(snd((1,0) )) <- var_o ()  ;
		t_val.(13) <- t_reg.(13) ;
		t_val.(0) <- t_reg.(0) ;
		t_val.(11) <- t_reg.(11) ;
		done

let () = Arg.usage 
	["-n", Arg.Set_int number_steps, "Number of steps to simulate";
	 "-s", Arg.Clear print_sorties, "Disable print outputs";
	 "-rom", Arg.Set_string dossier_rom, "Roms' directory"] ""

let () = simulator () 
