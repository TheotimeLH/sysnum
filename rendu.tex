\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 


% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[driver = pdftex, margin = 2cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{microtype}

\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{array}  %tableaux
\usepackage{tabularx} %pour des tableau encore mieux
\usepackage{multirow} %dans les tableaux encore
\usepackage{makecell}



\title{Projet de systèmes numériques \\ Spécifications, choix à imlpémenter}
\author{Samuel Coulomb, Laura Gruson, Théotime Le Hellard, Vincent Peth}

\begin{document}
\maketitle

\section{Vue d’ensemble}



\section{Choix réalisés}
\begin{enumerate}
    \item Nombre de registre : 8
    \item Rôle de chaque registre : un registre pour les secondes, un pour les minutes, et un pour les heures.
    \item Nombre de bits : 4 registres à 8 bits (dont les secondes, les minutes et les heures) et 4 registres à 16 bits
    \item Affichage (pb : si on décide de stocker ce qu’il faut afficher sur de la ram, il faut une ram par unité, pour pouvoir les mettre à jour en même temps, ou bien on doit plutôt faire circuler les retenues sur plusieurs cycles)
\end{enumerate}


\section{Assembleur, encodage et décodage}
\subsection{langage assembleur}

%Comment représenter les nombres, les adresses mémoire, l’appel à un registre etc
Les types des différents arguments peuvent être des entiers (<int> notés avec un entier ou un dollar suivi du nom du registre : \texttt{42}, \texttt{\$rax}), des noms de registres (<reg> dénotés par leur noms), et des adresses (<addr>, notés entre parenthèses : (42), (\$rax + 42)).

On utilisera de plus des étiquettes pour les sauts et sauts conditionnels, qui seront transformés en entiers (numéro de lignes) par le compilateur, on les notera <int>*

On représente les instructions sur 32 bits. Les huits premiers bits encodent l’instruction, les suivant représentent les paramètres.

%On peut aussi créer des commandes fortement typées


\begin{tabular}{|c|c|c|}
    \hline
    Commande & Représentation binaire & Signification  \\
    \hline \hline
    move <reg>1 <reg>2 & 00000001 & met le registre 2 à la même valeur que le registre 1\\
    \hline
    set <int> <reg> & 00000010 & met le registre à la valeur de l’entier\\
    \hline
    load <addr> <reg> & 00000100 &\makecell{ le registre prend la valeurs stockée\\ dans la ram à l’adresse donnée}\\
    \hline
    incrm <reg> <int> & 00001000 & \makecell{ incrémente ce registre modulo l’entier,\\ lève un drapeau en cas de dépassement}\\
    \hline
    input <reg> & 00010000 & lit une entrée et l’assigne au registre\\
    \hline
    save <reg> <addr> & 00100000 & \makecell{enregistre la valeur du registre \\ à l’adresse donnée dans la ram}\\
    \hline
    jump <int>* & 01000000 & saut inconditionnel\\
    \hline
    jump\_non\_nul <int> & 10000000 & saut si le drapeau nul vaut faux\\
    \hline
    jump\_nul <int> & 00000111 & saut si le drapeau nul vaut vrai
    \\ \hline
\end{tabular}



\subsection{Décodeur}
Entrées :
\begin{enumerate}
    \item \texttt{curr\_code} : code de la commande à effectuer (32 bits)
\end{enumerate}

Sorties :
\begin{enumerate}
    \item \texttt{jump\_line} : ligne du programme à laquelle il faut sauter
    \item \texttt{jump\_flag} : vaut 1 si il faut sauter, 0 sinon
    \item \texttt{operation} : code binaire de l’opération
    \item \texttt{entier} : vaut l’entier donné en argument 
    \item \texttt{read\_addr1} 
    \item \texttt{read\_addr2}
    \item \texttt{write\_addr\_reg}
    \item \texttt{write\_addr\_ram}
    \item \texttt{write\_enable\_reg}
    \item \texttt{write\_enable\_ram}
\end{enumerate}

\subsection{Lecteur de code}

Entrées :
\begin{enumerate}
    \item \texttt{jump\_line}
    \item \texttt{jump\_flag}
\end{enumerate}

Sorties :
\begin{enumerate}
    \item \texttt{curr\_code} (lu dans la rom à l’adresse \texttt{curr\_line})
\end{enumerate}

Variable interne \texttt{curr\_line} incrémentée à chaque tour d’horloge

\section{Gestionnaire des registres}
Entrées :
\begin{enumerate}
    \item \texttt{read\_addr1} 
    \item \texttt{read\_addr2}
    \item \texttt{write\_addr\_reg}
    \item \texttt{write\_enable\_reg}
    \item \texttt{write\_value\_reg}
\end{enumerate}

Sorties : 
\begin{enumerate}
    \item \texttt{value\_reg\_1}
    \item \texttt{value\_reg\_2}
\end{enumerate}


\section{ALU}
\subsection{interface de l’alu}

Entrées :
\begin{enumerate}
    \item \texttt{value\_reg\_1}
    \item \texttt{value\_reg\_2}
    \item \texttt{entier}
    \item \texttt{resultat_nul}
\end{enumerate}

Sorties : 
\begin{enumerate}
    \item \texttt{value\_1}
    \item \texttt{value\_2}
    \item \texttt{resultat\_precedent\_nul} : valeur du drapeau \texttt{resultat\_nul} après l’exécution de la commande précédente
\end{enumerate}

\subsection{alu}
Entrées :
    \begin{enumerate}
        \item \texttt{value\_1}
        \item \texttt{value\_2}
        \item \texttt{operation}
        
    \end{enumerate}

Sorties :
    \begin{enumerate}
        \item \texttt{resultat}
        \item \texttt{resultat\_nul}
    \end{enumerate}


\end{document}



